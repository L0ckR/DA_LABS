\documentclass[12pt,a4paper]{article}

% --- Русский язык и кодировки ---
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

% --- Поля и межстрочные ---
\usepackage{geometry}
\geometry{margin=2cm}
\usepackage{setspace}
\onehalfspacing

% --- Оформление ---
\usepackage{indentfirst}
\usepackage{enumitem}
\setlist{nosep}

% --- Математика ---
\usepackage{amsmath,amssymb}

% --- Код ---
\usepackage{listings}
\usepackage{xcolor}
\lstdefinestyle{cppstyle}{
  language=C++,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray!70},
  stringstyle=\color{green!40!black},
  numbers=left,
  numberstyle=\tiny\color{gray!70},
  stepnumber=1,
  numbersep=8pt,
  tabsize=2,
  showstringspaces=false,
  breaklines=true,
  frame=single
}

% --- Заголовки разделов ---
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{0.5em}{}

% --- Гиперссылки ---
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue, citecolor=black}

\usepackage{tikz}
\usepackage{pgfplots}
\begin{document}

% Титульный лист
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

        \textbf{ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ} \\
        \textbf{«МОСКОВСКИЙ АВИАЦИОННЫЙ ИНСТИТУТ (НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ)»}

        \vspace{3cm}

        \textbf{\LARGE ОТЧЕТ} \\
        \vspace{0.5cm}
        \textbf{\Large о выполнении лабораторной работы №8} \\
        \vspace{0.5cm}
        \textbf{\Large «Графы»} \\
        \vspace{1cm}

        \textbf{по дисциплине} \\
        \textit{«Дискретный анализ»}

        \vfill

        \begin{flushleft}
        Выполнил студент группы М8О-308Б-23: \\
        \textbf{Ибрагимов Далгат Магомедалиевич} \\
        \vspace{0.5cm}
        Проверил: \\
        \textbf{Макаров Н.К.}
        \end{flushleft}

        \vspace{3cm}

        Москва, 2025
    \end{center}
\end{titlepage}

\subsection*{Постановка задачи}
\textbf{Вариант 8: F.8 Поиск максимального паросочетания алгоритмом Куна}

Задан неориентированный двудольный граф из $n$ вершин и $m$ ребер. Вершины пронумерованы от $1$ до $n$.
Требуется найти максимальное паросочетание в графе алгоритмом Куна. Для однозначности ответа списки смежности
предварительно сортируются. Граф не содержит петель и кратных ребер.

\section*{Цель работы}
Изучение представления двудольных графов и реализация поиска максимального паросочетания с помощью алгоритма Куна
(поиск увеличивающих путей).

\section*{Задание}
\textbf{Формат ввода:}
В первой строке заданы $1 \le n \le 110000$ и $1 \le m \le 40000$.
В следующих $m$ строках записаны ребра: пара чисел — номера вершин, соединенных ребром.

\textbf{Формат вывода:}
В первой строке вывести число ребер в найденном паросочетании.
В следующих строках вывести ребра паросочетания по одному в строке.
Каждое ребро — пара номеров вершин. В каждой паре числа упорядочены по возрастанию.
Строки (ребра) отсортированы по минимальному номеру вершины на ребре.

\section*{Алгоритм решения}
Решение состоит из следующих этапов:

\begin{enumerate}
    \item \textbf{Чтение графа и построение списков смежности.} Граф неориентированный, поэтому каждое ребро добавляется в обе стороны.
    \item \textbf{Сортировка списков смежности.} Необходима для детерминированности выбора увеличивающих путей и однозначности результата.
    \item \textbf{Построение двудольного разбиения (раскраска в 2 цвета).} Так как вход задает только граф, а не доли, разбиение восстанавливается BFS-раскраской по компонентам связности.
    \item \textbf{Поиск максимального паросочетания алгоритмом Куна.}
    Для каждой вершины левой доли (цвет 0) запускается DFS-поиск увеличивающего пути. Массив $mt$ хранит текущую пару для вершин правой доли (цвет 1): $mt[v] = u$ означает, что вершина $v$ сматчена с $u$.
    \item \textbf{Формирование и сортировка ответа.} Из массива $mt$ собираются ребра паросочетания, внутри ребра вершины упорядочиваются, затем весь список сортируется лексикографически (что эквивалентно требованию сортировки по минимальному номеру вершины).
\end{enumerate}

\section*{Реализация программы}
Программа реализована на языке C++ и включает ключевые компоненты:

\begin{itemize}
    \item \texttt{BFS}-раскраска вершин (\texttt{side}) для восстановления долей двудольного графа.
    \item \texttt{bool kuhn(int v)} — DFS-поиск увеличивающего пути из вершины левой доли.
    \item \texttt{mt} — массив соответствий для вершин правой доли.
\end{itemize}

Для ускорения работы на больших $n$ используется ``таймер'' посещений: вместо переинициализации массива \texttt{used}
на каждой итерации применяется массив целых меток и счетчик запусков.

\section*{Листинг кода}
\lstset{style=cppstyle}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

int n, m;
vector<vector<int>> g;
vector<int> side;        
vector<int> mt;          
vector<int> used;  
int timer = 0;

bool kuhn(int v) {
    if (used[v] == timer) return false;
    used[v] = timer;

    for (int to : g[v]) {
        if (mt[to] == -1 || kuhn(mt[to])) {
            mt[to] = v;
            return true;
        }
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    g.assign(n, {});

    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        --u; --v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    for (int i = 0; i < n; ++i) {
        sort(g[i].begin(), g[i].end());
    }

    side.assign(n, -1);
    for (int i = 0; i < n; ++i) {
        if (side[i] != -1) continue;
        queue<int> q;
        side[i] = 0;
        q.push(i);
        while (!q.empty()) {
            int v = q.front(); q.pop();
            for (int to : g[v]) {
                if (side[to] == -1) {
                    side[to] = side[v] ^ 1;
                    q.push(to);
                }
            }
        }
    }
    
    mt.assign(n, -1);
    used.assign(n, 0);

    for (int v = 0; v < n; ++v) {
        if (side[v] == 0) {
            ++timer;
            kuhn(v);
        }
    }

    vector<pair<int,int>> ans;
    for (int v = 0; v < n; ++v) {
        if (mt[v] != -1) {
            int a = mt[v] + 1;
            int b = v + 1;
            if (a > b) swap(a, b);
            ans.emplace_back(a, b);
        }
    }

    sort(ans.begin(), ans.end());

    cout << ans.size() << "\n";
    for (auto &e : ans) {
        cout << e.first << " " << e.second << "\n";
    }

    return 0;
}
\end{lstlisting}

\section*{Описание работы программы}
Программа читает граф, строит списки смежности и сортирует их, чтобы обеспечить детерминированность обходов.
Далее выполняется BFS-раскраска вершин в два цвета, восстанавливающая разбиение на доли (левая/правая).
После этого запускается алгоритм Куна: для каждой вершины левой доли выполняется поиск увеличивающего пути
в текущем паросочетании. Если путь найден, паросочетание увеличивается на одно ребро.

После завершения поиска из массива соответствий формируется список ребер, каждое ребро приводится к виду
$(\min(u,v), \max(u,v))$, а затем весь список сортируется и выводится.

\section*{Дневник отладки}
\begin{enumerate}
    \item Проверена корректность формирования списков смежности для неориентированного графа (добавление в обе стороны).
    \item Добавлена сортировка списков смежности для обеспечения однозначности результата.
    \item Реализована BFS-раскраска для восстановления долей на произвольном двудольном графе с несколькими компонентами.
    \item Оптимизирована отметка посещений в DFS (таймер), чтобы избежать $O(n)$ переинициализации на каждой итерации.
\end{enumerate}

\section*{Оценка сложности}
\begin{itemize}
    \item Сортировка списков смежности: суммарно $O(m \log m)$ (точнее, сумма по вершинам).
    \item BFS-раскраска: $O(n + m)$.
    \item Алгоритм Куна: в худшем случае $O(|L|\cdot m)$, где $|L|$ — число вершин левой доли.
    \item Память: $O(n + m)$.
\end{itemize}

С учетом ограничений $m \le 40000$ граф разреженный, поэтому на практике алгоритм работает эффективно.
\subsection*{Тест производительности}
Сложность алгоритма (в худшем случае) оценивается как $O(|L|\cdot m)$ для DFS-версии алгоритма Куна,
а также присутствуют затраты $O(n+m)$ на раскраску BFS и сортировку списков смежности.
Ниже приведены экспериментальные замеры времени работы для $n=110000$ при различных $m$.
Для каждого $m$ выполнено 9 прогонов на случайных двудольных графах, в график занесена медиана.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={$m$ ($\times 10^3$)},
            ylabel={time (ms)},
            grid=major,
            xmin=0, xmax=45,
            ymin=0, ymax=10,
            xtick={0,5,10,20,30,40,45},
            ytick={0,2,4,6,8,10},
            legend style={at={(0.5,-0.2)},anchor=north},
            width=0.85\textwidth,
            height=0.5\textwidth,
        ]
        \addplot[mark=*] coordinates {
            (5, 4.464)
            (10, 4.886)
            (20, 6.271)
            (30, 7.440)
            (40, 7.700)
        };
        \addlegendentry{Kuhn, $n=110000$ (median of 9 runs)}
        \end{axis}
    \end{tikzpicture}
    \caption{Зависимость времени работы от числа ребер $m$ при фиксированном $n=110000$}
    \label{fig:perf_kuhn}
\end{figure}

\section*{Результаты тестирования}
Программа успешно продемонстрировала корректные результаты для различных наборов входных данных. Это подтверждает правильность выбранного алгоритма и его эффективность в решении поставленной задачи.
\newpage
\subsection*{Выводы}
В ходе выполнения лабораторной работы была реализована программа для поиска максимального паросочетания в двудольном графе
алгоритмом Куна. Были рассмотрены вопросы восстановления долей двудольного графа по исходному неориентированному описанию,
а также обеспечена однозначность ответа путем сортировки списков смежности и выходных ребер. Реализация подтверждена тестами
и соответствует формату вывода задачи.

\end{document}
