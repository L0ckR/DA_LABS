\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{indentfirst}

\usepackage[figurename=Fig.]{caption}
\usepackage{tikz}
\usepackage{pgfplots}

\begin{document}

\section*{Лабораторная работа №\,2 по курсу дискрeтного анализа: сбалансированные деревья}

\noindent Выполнил студент группы 08-208 МАИ \textit{Ибрагимов Далгат}.

\subsection*{Условие}
\textbf{Общая постановка задачи:} Необходимо создать программную библиотеку, реализующую указанную структуру данных, на основе которой разработать программу-словарь. В словаре каждому ключу, представляющему из себя регистронезависимую последовательность букв английского алфавита длиной не более 256 символов, поставлен в соответствие некоторый номер, от 0 до ${2^{64} - 1}$. Разным словам может быть поставлен в соответствие один и тот же номер.

Программа должна обрабатывать строки входного файла до его окончания. Каждая строка может иметь следующий формат:
\begin{itemize}
\item+ word 34 — добавить слово «word» с номером 34 в словарь. Программа должна вывести строку «OK», если операция прошла успешно, «Exist», если слово уже находится в словаре.
\item- word — удалить слово «word» из словаря. Программа должна вывести «OK», если слово существовало и было удалено, «NoSuchWord», если слово в словаре не было найдено.
\itemword — найти в словаре слово «word». Программа должна вывести «OK: 34», если слово было найдено; число, которое следует за «OK:» — номер, присвоенный слову при добавлении. В случае, если слово в словаре не было обнаружено, нужно вывести строку «NoSuchWord».
\item! Save /path/to/file — сохранить словарь в бинарном компактном представлении на диск в файл, указанный парамером команды. В случае успеха, программа должна вывести «OK», в случае неудачи выполнения операции, программа должна вывести описание ошибки (см. ниже).
\item! Load /path/to/file — загрузить словарь из файла. Предполагается, что файл был ранее подготовлен при помощи команды Save. В случае успеха, программа должна вывести строку «OK», а загруженный словарь должен заменить текущий (с которым происходит работа); в случае неуспеха, должна быть выведена диагностика, а рабочий словарь должен остаться без изменений. Кроме системных ошибок, программа должна корректно обрабатывать случаи несовпадения формата указанного файла и представления данных словаря во внешнем файле.
\end{itemize}

\textbf{Вариант структуры данных:} Декартово дерево

\subsection*{Метод решения}

Моя программа реализует структуру данных Treap, которая объединяет свойства двоичного дерева поиска (BST) и кучи (heap). Treap используется для хранения пар ключ-значение и поддерживает быстрое выполнение операций вставки, удаления и поиска. Программа обрабатывает команды из входного файла до его окончания, разделяя ввод на команду, ключ и значение. В зависимости от команды выполняются соответствующие действия:

Если команда начинается с +, программа считывает ключ и значение, проверяет наличие ключа в дереве, и если его нет, добавляет новую пару в дерево. Если ключ уже существует, выводится соответствующее сообщение.
Если команда начинается с - , программа удаляет элемент с указанным ключом из дерева.
При вводе ключа без команды программа осуществляет поиск этого ключа в дереве и выводит значение, если ключ найден.
Команды ! Save и ! Load выполняют сохранение и загрузку дерева из бинарного файла.
Treap поддерживает основное свойство кучи: для любого узла приоритет этого узла больше приоритета его потомков. Это свойство сохраняется при всех операциях над деревом, таких как вставка и удаление. Для этого реализованы следующие функции:

\begin{itemize}
\item Node* insert(Node* root, Node* node) — вставка узла с балансировкой приоритетов.
\item Node* erase(Node* root, const char* key) — удаление узла с поддержанием свойств кучи.
\end{itemize}

\subsection*{Описание программы}

Для выполнения задания был разработан один класс и одна структура:

\begin{itemize}
\item struct Node — структура для представления узла дерева Treap. Узел содержит ключ, значение, приоритет и указатели на левые и правые поддеревья.
\item class Treap — реализация Treap, включающая методы для добавления, удаления, поиска узлов, а также для сохранения и загрузки дерева в/из бинарного файла.
\end{itemize}

Основные методы класса Treap:

\begin{itemize}
\item const char* add(const char* word, uint64\_t number) — добавление новой пары ключ-значение в дерево.
\item const char* del(const char* word) — удаление пары ключ-значение из дерева.
\item const char* search(const char* word) — поиск значения по ключу.
\item const char* save(const char* filename) — сохранение текущего состояния дерева в бинарный файл.
\item const char* load(const char* filename) — загрузка дерева из бинарного файла.
\end{itemize}
Программа использует структуру данных Treap для хранения словаря, где ключами являются строки, а значениями — числа.

\subsection*{Дневник отладки}
Во время разработки возникла проблема с корректностью чтения и записи данных в бинарный файл. Проблема заключалась в неверной обработке формата данных при сохранении и загрузке, что приводило к ошибкам при чтении файла. Для устранения этой проблемы был перепроверен порядок записи и чтения данных, а также учтены возможные ошибки при работе с бинарными файлами.

Еще одной сложностью стало управление памятью для строковых данных. В процессе разработки были учтены особенности динамического выделения и освобождения памяти для строк, что позволило избежать утечек памяти.

\subsection*{Тест производительности}

Для проверки производительности моего словаря в виде AVL-дерева я использовала сравнение со стандартным контейнером std::map. Это имеет смысл так как в его основе лежит красно-черное дерево, которое тоже является сбалансированным.
Сравнение производилось на входных данных больших размеров, не превышающих ${10^5}$. 

Исходя из графика, представленного ниже, можно увидеть, что вставка (аналогично с удалением) элементов в std::map работает быстрее, чем в AVL-дереве, а с поиском ситуация противоположна. Это происходит в силу различий в алгоритмах балансировки: в красно-черных деревьях она происходит гораздо реже, чем в AVL-дереве. Как следствие вставка (удаление) происходит быстрее. Однако высота красно-черного дерева больше высоты соответствующего AVL-дерева. Отсюда вытекает большее время поиска.
Не логарифмическая зависимость на графиках, по моему мнению, получается из-за довольно частых выделений/освобождений памяти на кучи, а это, как известно, не дешевая в плане времени операция. К тому же графики имеют очень похожую форму, что говорит об асимптотически одинаковой скорости роста времени выполнения операций.

\begin{figure}[htbp]
    \centering
    \caption*{Вставка} 
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Объём входных данных ($\times 10^6$)},
            ylabel={Время работы (s)},
            grid=major,
            xmin=0, xmax=1,
            ymin=0, ymax=30,            
            xtick={0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1},
            ytick={0, 5, 10, 15, 20, 25, 30},
            legend style={at={(0.5,-0.2)},anchor=north},
            legend columns=2,
            width=0.8\textwidth,
            height=0.5\textwidth,
            ]
            \addplot[color=red,mark=*] coordinates {
                (0,0)
                (0.1,0.852748)
                (0.2,1.69342)
                (0.3,2.56223)
                (0.4,3.49793)
                (0.5,4.56477)
                (0.6,5.55291)
                (0.7,6.30107)
                (0.8,7.4295)
                (0.9,8.52007)
                (1,9.36396)
            };
            \addlegendentry{std::map}
            \addplot[color=green,mark=square] coordinates {
                (0,0)
                (0.1,2.16856)
                (0.2,5.22381)
                (0.3,8.20415)
                (0.4,10.8336)
                (0.5,13.8025)
                (0.6,16.8357)
                (0.7,19.69)
                (0.8,24.125)
                (0.9,26.5546)
                (1,28.7225)
            };
            \addlegendentry{Treap}
        \end{axis}
    \end{tikzpicture}
    \label{fig:graph}
\end{figure}

\begin{figure}[htbp]
    \centering
    \caption*{Поиск} 
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Объём входных данных ($\times 10^6$)},
            ylabel={Время работы (s)},
            grid=major,
            xmin=0, xmax=1,
            ymin=0, ymax=30,
            xtick={0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1},
            ytick={0, 5, 10, 15, 20, 25, 30},
            legend style={at={(0.5,-0.2)},anchor=north},
            legend columns=2,
            width=0.8\textwidth,
            height=0.5\textwidth,
            ]
            \addplot[color=red,mark=*] coordinates {
                            (0,0)
                (0.1,0.444991)
                (0.2,0.936693)
                (0.3,1.4288)
                (0.4,1.93942)
                (0.5,2.55427)
                (0.6,3.19538)
                (0.7,3.52398)
                (0.8,4.19415)
                (0.9,4.7441)
                (1,5.12762)
            };
            \addlegendentry{std::map}
            \addplot[color=green,mark=square] coordinates {
                (0,0)
                (0.1,1.969)
                (0.2,4.5552)
                (0.3,7.10988)
                (0.4,9.75504)
                (0.5,12.5887)
                (0.6,15.0053)
                (0.7,17.9142)
                (0.8,20.7606)
                (0.9,25.0638)
                (1,26.4744)
            };
            \addlegendentry{Treap}
        \end{axis}
    \end{tikzpicture}
    \label{fig:graph}
\end{figure}

\newpage
\subsection*{Выводы}

%Описать область применения реализованного алгоритма. Указать типовые задачи, решаемые им. Оценить сложность программирования, кратко описать возникшие проблемы при решении задачи. 

Реализованный класс Treap позволяет эффективно управлять словарем с поддержкой операций вставки, удаления и поиска. Использование структуры данных Treap обеспечивает сбалансированное выполнение этих операций с учетом свойств двоичного дерева поиска и кучи. Программа успешно сохраняет и восстанавливает состояние дерева из бинарного файла, что делает её удобной для работы с большими объемами данных.
std::map показывает лучшую производительность при вставке по сравнению с Treap. std::map основан на красно-чёрных деревьях, которые обеспечивают балансировку с меньшими накладными расходами, что приводит к более эффективной вставке данных.
Treap, с другой стороны, имеет дополнительные накладные расходы, связанные с поддержанием структуры приоритета, что усложняет вставку и увеличивает её время.
std::map демонстрирует значительно лучшую производительность при выполнении поиска, что связано с эффективностью его балансировки и минимальными накладными расходами на поддержание структуры дерева.
Treap, напротив, требует больше времени для поиска из-за дополнительных операций, связанных с поддержанием приоритетов и случайных балансировок, что увеличивает сложность поиска.
\end{document}

